## 递归算法：本质就是数学归纳法

> 1. 明确递归终止条件；

> 2. 给出递归终止时的处理办法；

> 3. 提取重复的逻辑，缩小问题规模。

- 模型一： 在递去的过程中解决问题
```
function recursion(大规模){
    if (end_condition){      // 明确的递归终止条件
        end;   // 简单情景
    }else{            // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题
        solve;                // 递去
        recursion(小规模);     // 递到最深处后，不断地归来
    }
}
```

- 模型二： 在归来的过程中解决问题
```
function recursion(大规模){
    if (end_condition){      // 明确的递归终止条件
        end;   // 简单情景
    }else{            // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题
        recursion(小规模);     // 递去
        solve;                // 归来
    }
}
```

- 递归的应用场景:
	- 问题的定义是按递归定义的（Fibonacci函数，阶乘，…）；
	- 问题的解法是递归的（有些问题只能使用递归方法来解决，例如，汉诺塔问题，…）；
	- 数据结构是递归的（链表、树等的操作，包括树的遍历，树的深度，…）。

- 问题的递归实现转换成非递归实现一般需要两步工作:
	- 自己建立“堆栈(一些局部变量)”来保存这些内容以便代替系统栈，比如树的三种非递归遍历方式；
	- 把对递归的调用转变为对循环处理。
